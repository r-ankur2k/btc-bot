<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Crypto Bot</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background: #0d1117;
      color: #fff;
    }
    select, button {
      padding: 8px;
      font-size: 1em;
      margin: 10px 5px 10px 0; /* Adjusted margin */
      border-radius: 5px;
      border: 1px solid #30363d;
      background-color: #21262d;
      color: #fff;
      cursor: pointer;
    }
    select:focus, button:focus {
      outline: none;
      border-color: #007bff;
    }
    button:hover {
      background-color: #30363d;
    }
    #chart-container {
      max-width: 800px;
      margin: 20px auto;
    }
    canvas {
      background: #161b22;
      border-radius: 10px;
      padding: 10px;
    }
    #price, #advice, #analysis, #metrics {
      margin-top: 15px;
      font-size: 1.1em;
      background-color: #161b22;
      padding: 10px 15px;
      border-radius: 8px;
      border: 1px solid #30363d;
    }
    #price {
        font-size: 1.5em;
        font-weight: bold;
        text-align: center;
        color: #00ff99;
    }
    #metrics, #analysis {
        margin-top: 10px;
        line-height: 1.6;
    }
    #metrics span, #analysis span {
        display: inline-block;
        margin-right: 15px;
        padding: 3px 8px;
        border-radius: 4px;
        background-color: #21262d;
        border: 1px solid #30363d;
        margin-bottom: 5px; /* Added for better spacing in multiple lines */
    }
    #advice {
        font-weight: bold;
        text-align: center;
        padding: 15px;
        color: #fff;
    }
    .bullish { color: #00ff99; }
    .bearish { color: #ff6384; }
    .neutral { color: #ffe66d; }

    /* Style for the advanced metrics container */
    #advancedMetrics {
      display: none; /* Hidden by default */
      margin-top: 10px;
      background-color: #161b22;
      padding: 10px 15px;
      border-radius: 8px;
      border: 1px solid #30363d;
    }
    #toggleMetricsButton {
        background-color: #007bff;
        border-color: #007bff;
        color: white;
    }
    #toggleMetricsButton:hover {
        background-color: #0056b3;
        border-color: #0056b3;
    }
  </style>
</head>
<body>
  <h2>Crypto Bot - Live Analysis</h2>
  <label for="coin">Choose Coin: </label>
  <select id="coin">
    <option value="bitcoin">Bitcoin (BTC)</option>
    <option value="ethereum">Ethereum (ETH)</option>
    <option value="solana">Solana (SOL)</option>
    <option value="cardano">Cardano (ADA)</option>
    <option value="dogecoin">Dogecoin (DOGE)</option>
    <option value="ripple">Ripple (XRP)</option>
    <option value="litecoin">Litecoin (LTC)</option>
    <option value="polkadot">Polkadot (DOT)</option>
  </select>
  <button onclick="fetchData()">Refresh</button>
  <button id="toggleMetricsButton">Show Advanced Metrics</button>

  <div id="price">Loading...</div>
  <div id="metrics"></div>

  <div id="advancedMetrics">
      <h3>Advanced Metrics</h3>
      <div id="advancedMetricsContent"></div>
  </div>

  <div id="analysis"></div>

  <div id="chart-container">
    <canvas id="cryptoChart" width="600" height="300"></canvas>
  </div>

  <div id="advice"></div>

  <script>
    let chart;

    // Helper function to calculate EMA
    function calculateEMA(prices, period) {
        if (prices.length < period) return Array(prices.length).fill(NaN);
        const k = 2 / (period + 1);
        let ema = prices[0];
        const emas = [ema];

        for (let i = 1; i < prices.length; i++) {
            ema = (prices[i] * k) + (ema * (1 - k));
            emas.push(ema);
        }
        return emas;
    }

    // Helper function to calculate Standard Deviation
    function calculateStandardDeviation(prices, period) {
        if (prices.length < period) return 0;
        const slice = prices.slice(-period);
        const mean = slice.reduce((a, b) => a + b, 0) / period;
        const variance = slice.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b, 0) / period;
        return Math.sqrt(variance);
    }

    // Helper function to calculate RSI
    function calculateRSI(prices, period = 14) {
        if (prices.length < period + 1) return NaN;
        let gains = 0, losses = 0;
        // Calculate gains and losses for the latest 'period' prices
        for (let i = prices.length - period; i < prices.length; i++) {
          let diff = prices[i] - prices[i - 1];
          if (diff >= 0) gains += diff;
          else losses -= diff;
        }
        const avgGain = gains / period;
        const avgLoss = losses / period;
        const rs = avgGain / (avgLoss || 0.0001);
        return 100 - (100 / (1 + rs));
    }

    // Helper function to calculate Stochastic Oscillator (%K and %D)
    function calculateStochastic(prices, periodK = 14, periodD = 3) {
        if (prices.length < periodK) return { K: NaN, D: NaN };

        const currentPrice = prices[prices.length - 1];

        // For %K, calculate for the very last period
        const periodK_slice = prices.slice(-periodK);
        const lowestLowK = Math.min(...periodK_slice);
        const highestHighK = Math.max(...periodK_slice);
        const K = ((currentPrice - lowestLowK) / (highestHighK - lowestLowK || 0.0001)) * 100;

        // For %D, we need the SMA of %K values. Calculate %K for the last 'periodD' + 'periodK' - 1 points
        const kValues = [];
        for (let i = 0; i < prices.length; i++) {
            if (i >= periodK - 1) {
                const currentSlice = prices.slice(i - periodK + 1, i + 1);
                const sliceLowestLow = Math.min(...currentSlice);
                const sliceHighestHigh = Math.max(...currentSlice);
                const currentK = ((prices[i] - sliceLowestLow) / (sliceHighestHigh - sliceLowestLow || 0.0001)) * 100;
                kValues.push(currentK);
            }
        }
        const D = kValues.length >= periodD ? kValues.slice(-periodD).reduce((a, b) => a + b, 0) / periodD : NaN;

        return { K: K, D: D };
    }

    // Helper function to calculate Average True Range (ATR)
    function calculateATR(highs, lows, closes, period = 14) {
        if (highs.length < period || lows.length < period || closes.length < period) return NaN;

        const trueRanges = [];
        for (let i = 1; i < closes.length; i++) {
            const tr1 = highs[i] - lows[i];
            const tr2 = Math.abs(highs[i] - closes[i - 1]);
            const tr3 = Math.abs(lows[i] - closes[i - 1]);
            trueRanges.push(Math.max(tr1, tr2, tr3));
        }

        if (trueRanges.length < period) return NaN;

        // Calculate initial ATR (SMA of first 'period' true ranges)
        let atr = trueRanges.slice(0, period).reduce((a, b) => a + b, 0) / period;

        // Calculate subsequent ATRs (EMA-like smoothing)
        for (let i = period; i < trueRanges.length; i++) {
            atr = ((atr * (period - 1)) + trueRanges[i]) / period;
        }
        return atr;
    }


    async function fetchData() {
      const coin = document.getElementById('coin').value;
      const response = await fetch(
        `https://api.coingecko.com/api/v3/coins/${coin}/market_chart?vs_currency=usd&days=1`
      );
      const data = await response.json();

      const prices = data.prices;
      const timeLabels = prices.map(p => new Date(p[0]).toLocaleTimeString());
      const priceValues = prices.map(p => p[1]);
      const currentPrice = priceValues[priceValues.length - 1];

      // For ATR approximation, use current price values for close, and derive high/low
      // This is a simplification; for real trading, you'd need OHLCV data.
      const approximatedHighs = priceValues.map(p => p * 1.005);
      const approximatedLows = priceValues.map(p => p * 0.995);


      document.getElementById('price').innerText = `üí∞ Current Price: $${currentPrice.toFixed(2)}`;

      // Calculate MACD
      const fastPeriod = 12;
      const slowPeriod = 26;
      const signalPeriod = 9;

      const fastEMA = calculateEMA(priceValues, fastPeriod);
      const slowEMA = calculateEMA(priceValues, slowPeriod);

      const macdLine = fastEMA.length >= slowPeriod ? fastEMA.slice(slowPeriod - 1).map((f, i) => f - slowEMA[slowPeriod - 1 + i]) : [NaN];
      const signalLine = macdLine.length >= signalPeriod ? calculateEMA(macdLine, signalPeriod) : [NaN];
      const macdHistogram = macdLine.length >= signalPeriod ? macdLine.slice(signalPeriod - 1).map((m, i) => m - signalLine[i]) : [NaN];

      const latestMACD = macdLine[macdLine.length - 1];
      const latestSignal = signalLine[signalLine.length - 1];
      const latestHistogram = macdHistogram[macdHistogram.length - 1];

      // Calculate Bollinger Bands
      const bbPeriod = 20;
      const bbMultiplier = 2;

      const sma20 = priceValues.slice(-bbPeriod).reduce((a, b) => a + b, 0) / bbPeriod;
      const stdDev20 = calculateStandardDeviation(priceValues, bbPeriod);

      const upperBand = sma20 + (stdDev20 * bbMultiplier);
      const lowerBand = sma20 - (stdDev20 * bbMultiplier);

      // Calculate RSI
      const rsi = calculateRSI(priceValues, 14);

      // Calculate Stochastic Oscillator
      const stochastic = calculateStochastic(priceValues, 14, 3);
      const latestStochK = stochastic.K;
      const latestStochD = stochastic.D;

      // Calculate ATR (using approximated high/low)
      const atr = calculateATR(approximatedHighs, approximatedLows, priceValues, 14);


      if (chart) chart.destroy();

      chart = new Chart(document.getElementById('cryptoChart'), {
        type: 'line',
        data: {
          labels: timeLabels,
          datasets: [
            {
              label: `${coin.toUpperCase()} Price (USD)`,
              data: priceValues,
              borderColor: '#00ff99',
              fill: false,
              tension: 0.2,
              pointRadius: 0
            },
            // Bollinger Bands can be added to the chart, but for simplicity and decluttering,
            // we'll keep only the price on the main chart by default.
            // If you want to add them back to the chart, uncomment these:
            /*
            {
                label: 'Upper Bollinger Band',
                data: Array(priceValues.length - bbPeriod).fill(NaN).concat(priceValues.slice(bbPeriod).map((_, i) => sma20 + (calculateStandardDeviation(priceValues.slice(0, bbPeriod + i), bbPeriod) * bbMultiplier))),
                borderColor: 'rgba(255, 206, 86, 0.5)',
                borderDash: [5, 5],
                fill: false,
                tension: 0.2,
                pointRadius: 0
            },
            {
                label: 'Lower Bollinger Band',
                data: Array(priceValues.length - bbPeriod).fill(NaN).concat(priceValues.slice(bbPeriod).map((_, i) => sma20 - (calculateStandardDeviation(priceValues.slice(0, bbPeriod + i), bbPeriod) * bbMultiplier))),
                borderColor: 'rgba(255, 206, 86, 0.5)',
                borderDash: [5, 5],
                fill: false,
                tension: 0.2,
                pointRadius: 0
            },
            */
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              ticks: { color: '#ccc' },
              grid: { color: '#30363d' }
            },
            y: {
              ticks: { color: '#ccc' },
              grid: { color: '#30363d' }
            }
          },
          plugins: {
              legend: {
                  labels: {
                      color: '#fff'
                  }
              }
          }
        }
      });

      // Advice logic
      let advice = '';
      if (currentPrice > priceValues[0] * 1.01) advice = '<span class="bullish">üìà Price is significantly up ‚Äî consider watching for breakout or profit-taking.</span>';
      else if (currentPrice < priceValues[0] * 0.99) advice = '<span class="bearish">üìâ Price is significantly down ‚Äî could be a dip opportunity or further decline.</span>';
      else advice = '<span class="neutral">‚è∏Ô∏è No major price move yet ‚Äî market might be consolidating.</span>';

      // Enhanced Advice based on new indicators
      // MACD Advice
      if (!isNaN(latestMACD) && !isNaN(latestSignal)) {
          if (latestMACD > latestSignal && latestHistogram > 0) {
              advice += '<br><span class="bullish">MACD: Bullish crossover and positive histogram - momentum is strong.</span>';
          } else if (latestMACD < latestSignal && latestHistogram < 0) {
              advice += '<br><span class="bearish">MACD: Bearish crossover and negative histogram - momentum is weakening.</span>';
          } else {
              advice += '<br><span class="neutral">MACD: Signals are neutral or indecisive.</span>';
          }
      }

      // Bollinger Bands Advice
      if (!isNaN(upperBand) && !isNaN(lowerBand)) {
          if (currentPrice > upperBand) {
              advice += '<br><span class="bearish">Bollinger Bands: Price above upper band - potentially overbought.</span>';
          } else if (currentPrice < lowerBand) {
              advice += '<br><span class="bullish">Bollinger Bands: Price below lower band - potentially oversold.</span>';
          } else if (upperBand - lowerBand < (sma20 * 0.02)) {
              advice += '<br><span class="neutral">Bollinger Bands: Bands are squeezing - low volatility, potential for a breakout.</span>';
          } else {
              advice += '<br><span class="neutral">Bollinger Bands: Price within bands - market is ranging.</span>';
          }
      }

      // RSI Advice
      if (!isNaN(rsi)) {
          if (rsi > 70) {
              advice += `<br><span class="bearish">RSI: ${rsi.toFixed(2)} - Overbought conditions, potential for pullback.</span>`;
          } else if (rsi < 30) {
              advice += `<br><span class="bullish">RSI: ${rsi.toFixed(2)} - Oversold conditions, potential for rebound.</span>`;
          } else {
              advice += `<br><span class="neutral">RSI: ${rsi.toFixed(2)} - Neutral territory.</span>`;
          }
      }

      // Stochastic Oscillator Advice
      if (!isNaN(latestStochK) && !isNaN(latestStochD)) {
          if (latestStochK > 80 && latestStochD > 80) {
              advice += `<br><span class="bearish">Stochastic: %K ${latestStochK.toFixed(2)} / %D ${latestStochD.toFixed(2)} - Overbought, potential reversal.</span>`;
          } else if (latestStochK < 20 && latestStochD < 20) {
              advice += `<br><span class="bullish">Stochastic: %K ${latestStochK.toFixed(2)} / %D ${latestStochD.toFixed(2)} - Oversold, potential rebound.</span>`;
          } else if (latestStochK > latestStochD && latestStochK < 80 && latestStochD > 20) { // Bullish cross in neutral zone
              advice += `<br><span class="bullish">Stochastic: %K ${latestStochK.toFixed(2)} / %D ${latestStochD.toFixed(2)} - Bullish momentum.</span>`;
          } else if (latestStochK < latestStochD && latestStochK > 20 && latestStochD < 80) { // Bearish cross in neutral zone
              advice += `<br><span class="bearish">Stochastic: %K ${latestStochK.toFixed(2)} / %D ${latestStochD.toFixed(2)} - Bearish momentum.</span>`;
          } else {
              advice += `<br><span class="neutral">Stochastic: Signals are neutral or indecisive.</span>`;
          }
      }

      document.getElementById('advice').innerHTML = advice;

      // Basic Metrics (always visible)
      const ma20 = priceValues.slice(-20).reduce((a, b) => a + b, 0) / 20;
      const high24h = Math.max(...priceValues);
      const low24h = Math.min(...priceValues);

      document.getElementById('metrics').innerHTML = `
        <span>üîç <b>RSI:</b> ${isNaN(rsi) ? 'N/A' : rsi.toFixed(2)}</span>
        <span>üü¢ <b>20-period MA:</b> $${ma20.toFixed(2)}</span>
        <span>üìà <b>24h High:</b> $${high24h.toFixed(2)}</span>
        <span>üìâ <b>24h Low:</b> $${low24h.toFixed(2)}</span>
      `;

      // Advanced Metrics (hidden by default, shown by button)
      document.getElementById('advancedMetricsContent').innerHTML = `
        <span>üìä <b>Stoch %K:</b> ${isNaN(latestStochK) ? 'N/A' : latestStochK.toFixed(2)}</span>
        <span>üìä <b>Stoch %D:</b> ${isNaN(latestStochD) ? 'N/A' : latestStochD.toFixed(2)}</span>
        <span>üìä <b>MACD:</b> ${isNaN(latestMACD) ? 'N/A' : latestMACD.toFixed(2)}</span>
        <span>üìà <b>Signal Line:</b> ${isNaN(latestSignal) ? 'N/A' : latestSignal.toFixed(2)}</span>
        <span>üìâ <b>MACD Hist:</b> ${isNaN(latestHistogram) ? 'N/A' : latestHistogram.toFixed(2)}</span>
        <span>‚¨ÜÔ∏è <b>Upper BB:</b> $${isNaN(upperBand) ? 'N/A' : upperBand.toFixed(2)}</span>
        <span>‚¨áÔ∏è <b>Lower BB:</b> $${isNaN(lowerBand) ? 'N/A' : lowerBand.toFixed(2)}</span>
        <span>üí® <b>ATR:</b> ${isNaN(atr) ? 'N/A' : atr.toFixed(2)}</span>
      `;

      // Live analysis
      const change = ((currentPrice - priceValues[0]) / priceValues[0]) * 100;
      const volatility = ((high24h - low24h) / currentPrice) * 100;
      const trendClass = change > 0 ? 'bullish' : change < 0 ? 'bearish' : 'neutral';
      const trendText = change > 0 ? 'Bullish' : change < 0 ? 'Bearish' : 'Neutral';
      const volatilityLevel = volatility > 5 ? 'High Volatility' : volatility > 2 ? 'Moderate Volatility' : 'Low Volatility';
      const volatilityClass = volatility > 5 ? 'bearish' : volatility > 2 ? 'neutral' : 'bullish';

      document.getElementById('analysis').innerHTML = `
        <span>üìä <b>Trend:</b> <span class="${trendClass}">${trendText} (${change.toFixed(2)}%)</span></span>
        <span>üå™Ô∏è <b>Volatility:</b> <span class="${volatilityClass}">${volatilityLevel} (${volatility.toFixed(2)}%)</span></span>
      `;
    }

    // Toggle Advanced Metrics visibility
    document.getElementById('toggleMetricsButton').addEventListener('click', function() {
        const advancedMetricsDiv = document.getElementById('advancedMetrics');
        const button = document.getElementById('toggleMetricsButton');
        if (advancedMetricsDiv.style.display === 'none' || advancedMetricsDiv.style.display === '') {
            advancedMetricsDiv.style.display = 'block';
            button.textContent = 'Hide Advanced Metrics';
        } else {
            advancedMetricsDiv.style.display = 'none';
            button.textContent = 'Show Advanced Metrics';
        }
    });


    // Load default
    fetchData();
    // Refresh data every 5 minutes (300000 milliseconds)
    setInterval(fetchData, 300000);
  </script>
</body>
</html>
